<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>minisolvers.py &mdash; PyMiniSolvers 0.9 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.9',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyMiniSolvers 0.9 documentation" href="#" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">PyMiniSolvers 0.9 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="minisolvers-py">
<h1>minisolvers.py<a class="headerlink" href="#minisolvers-py" title="Permalink to this headline">¶</a></h1>
<p>[Hosted on GitHub: <a class="reference external" href="https://github.com/liffiton/PyMiniSolvers/">https://github.com/liffiton/PyMiniSolvers/</a>]</p>
<span class="target" id="module-minisolvers"></span><p>A Python API for the <a class="reference external" href="http://minisat.se/">MiniSat</a> and <a class="reference external" href="http://git.io/minicard">MiniCard</a> constraint solvers.</p>
<dl class="docutils">
<dt>Classes:</dt>
<dd><dl class="first last docutils">
<dt>Solver</dt>
<dd>An abstract base class for the other classes.</dd>
<dt>SubsetMixin</dt>
<dd>A mixin class adding &#8216;subset&#8217; functionality to Solver subclasses.</dd>
<dt><a class="reference internal" href="#minisolvers.MinisatSolver" title="minisolvers.MinisatSolver"><code class="xref py py-class docutils literal"><span class="pre">MinisatSolver</span></code></a></dt>
<dd>Solve CNF instances using MiniSat.</dd>
<dt><a class="reference internal" href="#minisolvers.MinicardSolver" title="minisolvers.MinicardSolver"><code class="xref py py-class docutils literal"><span class="pre">MinicardSolver</span></code></a></dt>
<dd>Solve CNF+ (CNF plus cardinality constraints) using MiniCard.</dd>
<dt><a class="reference internal" href="#minisolvers.MinisatSubsetSolver" title="minisolvers.MinisatSubsetSolver"><code class="xref py py-class docutils literal"><span class="pre">MinisatSubsetSolver</span></code></a></dt>
<dd>Solve arbitrary subsets of CNF instances and find SAT subsets / UNSAT cores.</dd>
<dt><a class="reference internal" href="#minisolvers.MinicardSubsetSolver" title="minisolvers.MinicardSubsetSolver"><code class="xref py py-class docutils literal"><span class="pre">MinicardSubsetSolver</span></code></a></dt>
<dd>Solve arbitrary subsets of CNF+ instances and find SAT subsets / UNSAT cores.</dd>
</dl>
</dd>
</dl>
<hr class="docutils" />
<dl class="class">
<dt id="minisolvers.MinisatSolver">
<em class="property">class </em><code class="descclassname">minisolvers.</code><code class="descname">MinisatSolver</code><a class="headerlink" href="#minisolvers.MinisatSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">minisolvers.Solver</span></code></p>
<p>A Python analog to MiniSat&#8217;s Solver class.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">MinisatSolver</span><span class="p">()</span>
</pre></div>
</div>
<p>Create variables using <code class="docutils literal"><span class="pre">new_var()</span></code>.  Add clauses as list of literals with
<code class="docutils literal"><span class="pre">add_clause()</span></code>, analogous to MiniSat&#8217;s <code class="docutils literal"><span class="pre">add_clause()</span></code>.  Literals are
specified as integers, with the magnitude indicating the variable index
(with 1-based counting) and the sign indicating True/False.  For example,
to add clauses (x0), (!x1), (!x0 + x1 + !x2), and (x2 + x3):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">S</span><span class="o">.</span><span class="n">new_var</span><span class="p">()</span>  
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="n">S</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span>  
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">solve()</span></code> method returns True or False just like MiniSat&#8217;s.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Models are returned as arrays of Booleans, indexed by var.
So the following represents x0=True, x1=False, x2=False, x3=True.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">get_model</span><span class="p">())</span>
<span class="go">[1, 0, 0, 1]</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">add_clause()</span></code> method may return False if a conflict is detected
when adding the clause, even without search.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="method">
<dt id="minisolvers.MinisatSolver.add_clause">
<code class="descname">add_clause</code><span class="sig-paren">(</span><em>lits</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.add_clause" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a clause to the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>lits:</dt>
<dd>A list of literals as integers.  Each integer specifies a
variable with <em>1</em>-based counting and a sign via the sign of the
integer.  Ex.: [-1, 2, -3] is (!x0 + x1 + !x2)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A boolean value returned from MiniSat&#8217;s <code class="docutils literal"><span class="pre">addClause()</span></code> function,
indicating success (True) or conflict (False).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSolver.get_model">
<code class="descname">get_model</code><span class="sig-paren">(</span><em>start=0</em>, <em>end=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current model from the solver, optionally retrieving only a slice.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>start, end (int):</dt>
<dd>Optional start and end indices, interpreted as in <code class="docutils literal"><span class="pre">range()</span></code>.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of booleans indexed to each variable (from 0).  If a start
index was given, the returned list starts at that index (i.e.,
<code class="docutils literal"><span class="pre">get_model(10)[0]</span></code> is index 10 from the solver&#8217;s model.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSolver.get_model_trues">
<code class="descname">get_model_trues</code><span class="sig-paren">(</span><em>start=0</em>, <em>end=-1</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.get_model_trues" title="Permalink to this definition">¶</a></dt>
<dd><p>Get variables assigned true in the current model from the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>start, end (int):</dt>
<dd>Optional start and end indices, interpreted as in <code class="docutils literal"><span class="pre">range()</span></code>.</dd>
<dt>offset (int):</dt>
<dd>Optional offset to be added to the zero-based variable numbers
from MiniSat.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of true variables in the solver&#8217;s current model.  If a
start index was given, the variables are indexed from that value.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSolver.implies">
<code class="descname">implies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.implies" title="Permalink to this definition">¶</a></dt>
<dd><p>Get literals known to be implied by the current formula.  (I.e., all
assignments made at level 0.)</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>An array of literals.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSolver.model_value">
<code class="descname">model_value</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.model_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of a given variable in the current model.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSolver.nclauses">
<code class="descname">nclauses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.nclauses" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of clauses or constraints added to the solver.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSolver.new_var">
<code class="descname">new_var</code><span class="sig-paren">(</span><em>polarity=None</em>, <em>dvar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.new_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new variable in the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>polarity (bool):</dt>
<dd>The default polarity for this variable.  True = variable&#8217;s
default is True, etc.  Note that this is the reverse of the &#8216;user
polarity&#8217; in MiniSat, where True indicates the <em>sign</em> is True,
hence the default value is False.</dd>
<dt>dvar (bool):</dt>
<dd>Whether this variable will be used as a decision variable.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>The new variable&#8217;s index (0-based counting).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSolver.nvars">
<code class="descname">nvars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.nvars" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of variables created in the solver.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSolver.set_phase_saving">
<code class="descname">set_phase_saving</code><span class="sig-paren">(</span><em>ps</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.set_phase_saving" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the level of phase saving (0=none, 1=limited, 2=full (default)).</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSolver.set_rnd_pol">
<code class="descname">set_rnd_pol</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.set_rnd_pol" title="Permalink to this definition">¶</a></dt>
<dd><p>Set whether random polarities are used for decisions (overridden if vars are created with a user polarity other than None)</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSolver.simplify">
<code class="descname">simplify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Call Solver.simplify().</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSolver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the current set of clauses, optionally with a set of assumptions.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>assumptions:</dt>
<dd>An optional iterable returning literals as integers, specified as
in <code class="docutils literal"><span class="pre">add_clause()</span></code>.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>True if the clauses (and assumptions) are satisfiable, False otherwise.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="minisolvers.MinicardSolver">
<em class="property">class </em><code class="descclassname">minisolvers.</code><code class="descname">MinicardSolver</code><a class="headerlink" href="#minisolvers.MinicardSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">minisolvers.Solver</span></code></p>
<p>A Python analog to MiniCard&#8217;s Solver class.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">MinicardSolver</span><span class="p">()</span>
</pre></div>
</div>
<p>This has the same interface as <code class="xref py py-class docutils literal"><span class="pre">MiniSatSolver</span></code>, with the addition of
the <code class="docutils literal"><span class="pre">add_atmost()</span></code> method.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">S</span><span class="o">.</span><span class="n">new_var</span><span class="p">()</span>  
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
<span class="gp">... </span>   <span class="n">S</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span>
<span class="go">True</span>
<span class="go">True</span>
<span class="go">True</span>
</pre></div>
</div>
<p>To add an AtMost constraint, specify the set of literals and the bound.  For example, to add AtMost({x0, !x1, x2}, 2):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">add_atmost</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">get_model</span><span class="p">())</span>
<span class="go">[1, 0, 0, 1]</span>
</pre></div>
</div>
<p>As with <code class="docutils literal"><span class="pre">add_clause()</span></code>, the <code class="docutils literal"><span class="pre">add_atmost()</span></code> method may return False if a
conflict is detected when adding the constraint, even without search.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">add_atmost</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="method">
<dt id="minisolvers.MinicardSolver.add_atmost">
<code class="descname">add_atmost</code><span class="sig-paren">(</span><em>lits</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.add_atmost" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an AtMost constraint to the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>lits:</dt>
<dd>A list of literals as integers.  Each integer specifies a
variable with <strong>1</strong>-based counting and a sign via the sign of
the integer.  Ex.: [-1, 2, -3] is {!x0, x1, !x2}</dd>
<dt>k (int):</dt>
<dd>The [upper] bound to place on these literals.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A boolean value returned from MiniCard&#8217;s <code class="docutils literal"><span class="pre">addAtMost()</span></code>
function, indicating success (True) or conflict (False).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.add_clause">
<code class="descname">add_clause</code><span class="sig-paren">(</span><em>lits</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.add_clause" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a clause to the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>lits:</dt>
<dd>A list of literals as integers.  Each integer specifies a
variable with <em>1</em>-based counting and a sign via the sign of the
integer.  Ex.: [-1, 2, -3] is (!x0 + x1 + !x2)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A boolean value returned from MiniSat&#8217;s <code class="docutils literal"><span class="pre">addClause()</span></code> function,
indicating success (True) or conflict (False).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.get_model">
<code class="descname">get_model</code><span class="sig-paren">(</span><em>start=0</em>, <em>end=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current model from the solver, optionally retrieving only a slice.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>start, end (int):</dt>
<dd>Optional start and end indices, interpreted as in <code class="docutils literal"><span class="pre">range()</span></code>.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of booleans indexed to each variable (from 0).  If a start
index was given, the returned list starts at that index (i.e.,
<code class="docutils literal"><span class="pre">get_model(10)[0]</span></code> is index 10 from the solver&#8217;s model.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.get_model_trues">
<code class="descname">get_model_trues</code><span class="sig-paren">(</span><em>start=0</em>, <em>end=-1</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.get_model_trues" title="Permalink to this definition">¶</a></dt>
<dd><p>Get variables assigned true in the current model from the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>start, end (int):</dt>
<dd>Optional start and end indices, interpreted as in <code class="docutils literal"><span class="pre">range()</span></code>.</dd>
<dt>offset (int):</dt>
<dd>Optional offset to be added to the zero-based variable numbers
from MiniSat.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of true variables in the solver&#8217;s current model.  If a
start index was given, the variables are indexed from that value.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.implies">
<code class="descname">implies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.implies" title="Permalink to this definition">¶</a></dt>
<dd><p>Get literals known to be implied by the current formula.  (I.e., all
assignments made at level 0.)</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>An array of literals.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.model_value">
<code class="descname">model_value</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.model_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of a given variable in the current model.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.nclauses">
<code class="descname">nclauses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.nclauses" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of clauses or constraints added to the solver.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.new_var">
<code class="descname">new_var</code><span class="sig-paren">(</span><em>polarity=None</em>, <em>dvar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.new_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new variable in the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>polarity (bool):</dt>
<dd>The default polarity for this variable.  True = variable&#8217;s
default is True, etc.  Note that this is the reverse of the &#8216;user
polarity&#8217; in MiniSat, where True indicates the <em>sign</em> is True,
hence the default value is False.</dd>
<dt>dvar (bool):</dt>
<dd>Whether this variable will be used as a decision variable.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>The new variable&#8217;s index (0-based counting).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.nvars">
<code class="descname">nvars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.nvars" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of variables created in the solver.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.set_phase_saving">
<code class="descname">set_phase_saving</code><span class="sig-paren">(</span><em>ps</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.set_phase_saving" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the level of phase saving (0=none, 1=limited, 2=full (default)).</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.set_rnd_pol">
<code class="descname">set_rnd_pol</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.set_rnd_pol" title="Permalink to this definition">¶</a></dt>
<dd><p>Set whether random polarities are used for decisions (overridden if vars are created with a user polarity other than None)</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.simplify">
<code class="descname">simplify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Call Solver.simplify().</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSolver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the current set of clauses, optionally with a set of assumptions.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>assumptions:</dt>
<dd>An optional iterable returning literals as integers, specified as
in <code class="docutils literal"><span class="pre">add_clause()</span></code>.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>True if the clauses (and assumptions) are satisfiable, False otherwise.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="minisolvers.MinisatSubsetSolver">
<em class="property">class </em><code class="descclassname">minisolvers.</code><code class="descname">MinisatSubsetSolver</code><a class="headerlink" href="#minisolvers.MinisatSubsetSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">minisolvers.SubsetMixin</span></code>, <a class="reference internal" href="#minisolvers.MinisatSolver" title="minisolvers.MinisatSolver"><code class="xref py py-class docutils literal"><span class="pre">minisolvers.MinisatSolver</span></code></a></p>
<p>A class for reasoning about subsets of constraints within MiniSat.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">MinisatSubsetSolver</span><span class="p">()</span>
</pre></div>
</div>
<p>It must be told explicitlyhow many of its variables are &#8220;real&#8221; and how many
are relaxation variables for constraints.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">set_varcounts</span><span class="p">(</span><span class="nb">vars</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">constraints</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="o">+</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">new_var</span><span class="p">()</span>
</pre></div>
</div>
<p>&#8220;Soft&#8221; clauses are added with <code class="docutils literal"><span class="pre">add_clause_instrumented()</span></code>, which has no
return value, as it is impossible for these clauses to produce a conflict.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">clause</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]):</span>
<span class="gp">... </span>    <span class="n">S</span><span class="o">.</span><span class="n">add_clause_instrumented</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>Any subset of the constraints can be tested for satisfiability.  Subsets
are specified as iterables containing soft clause indexes.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">solve_subset</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If a subset is found to be satisfiable, a potentially larger satisfied
subset can be found.  Satisfiable subsets are returned as array objects.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">satset</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">sat_subset</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">satset</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
<p>If a subset is found to be unsatisfiable, an UNSAT core can be found.
Cores are returned as array objects.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">solve_subset</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">core</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">unsat_core</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">core</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3]</span>
</pre></div>
</div>
<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.add_clause">
<code class="descname">add_clause</code><span class="sig-paren">(</span><em>lits</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.add_clause" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a clause to the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>lits:</dt>
<dd>A list of literals as integers.  Each integer specifies a
variable with <em>1</em>-based counting and a sign via the sign of the
integer.  Ex.: [-1, 2, -3] is (!x0 + x1 + !x2)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A boolean value returned from MiniSat&#8217;s <code class="docutils literal"><span class="pre">addClause()</span></code> function,
indicating success (True) or conflict (False).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.add_clause_instrumented">
<code class="descname">add_clause_instrumented</code><span class="sig-paren">(</span><em>lits</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.add_clause_instrumented" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a &#8220;soft&#8221; clause with a relaxation variable (the relaxation var.
is based on the index, which is assumed to be 0-based).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>lits:</dt>
<dd>A list of literals specified as in <code class="docutils literal"><span class="pre">add_clause()</span></code>.</dd>
<dt>index (int):</dt>
<dd>A 0-based index into the set of soft clauses.  The clause will
be given a relaxation variable based on this index, and it will
be used to specify the clause in subsets for
<code class="docutils literal"><span class="pre">solve_subset()</span></code>, etc.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.get_model">
<code class="descname">get_model</code><span class="sig-paren">(</span><em>start=0</em>, <em>end=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current model from the solver, optionally retrieving only a slice.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>start, end (int):</dt>
<dd>Optional start and end indices, interpreted as in <code class="docutils literal"><span class="pre">range()</span></code>.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of booleans indexed to each variable (from 0).  If a start
index was given, the returned list starts at that index (i.e.,
<code class="docutils literal"><span class="pre">get_model(10)[0]</span></code> is index 10 from the solver&#8217;s model.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.get_model_trues">
<code class="descname">get_model_trues</code><span class="sig-paren">(</span><em>start=0</em>, <em>end=-1</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.get_model_trues" title="Permalink to this definition">¶</a></dt>
<dd><p>Get variables assigned true in the current model from the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>start, end (int):</dt>
<dd>Optional start and end indices, interpreted as in <code class="docutils literal"><span class="pre">range()</span></code>.</dd>
<dt>offset (int):</dt>
<dd>Optional offset to be added to the zero-based variable numbers
from MiniSat.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of true variables in the solver&#8217;s current model.  If a
start index was given, the variables are indexed from that value.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.implies">
<code class="descname">implies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.implies" title="Permalink to this definition">¶</a></dt>
<dd><p>Get literals known to be implied by the current formula.  (I.e., all
assignments made at level 0.)</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>An array of literals.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.model_value">
<code class="descname">model_value</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.model_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of a given variable in the current model.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.nclauses">
<code class="descname">nclauses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.nclauses" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of clauses or constraints added to the solver.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.new_var">
<code class="descname">new_var</code><span class="sig-paren">(</span><em>polarity=None</em>, <em>dvar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.new_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new variable in the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>polarity (bool):</dt>
<dd>The default polarity for this variable.  True = variable&#8217;s
default is True, etc.  Note that this is the reverse of the &#8216;user
polarity&#8217; in MiniSat, where True indicates the <em>sign</em> is True,
hence the default value is False.</dd>
<dt>dvar (bool):</dt>
<dd>Whether this variable will be used as a decision variable.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>The new variable&#8217;s index (0-based counting).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.nvars">
<code class="descname">nvars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.nvars" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of variables created in the solver.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.sat_subset">
<code class="descname">sat_subset</code><span class="sig-paren">(</span><em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.sat_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the set of clauses satisfied in the last check performed by
<code class="docutils literal"><span class="pre">solve_subset()</span></code>.  Assumes the last such check was SAT.  This may
contain additional soft clauses not in the subset that was given to
<code class="docutils literal"><span class="pre">solve_subset()</span></code>, if they were also satisfied by the model found.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>offset (int):</dt>
<dd>Optional offset to be added to the zero-based indexes from
MiniSat.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of constraint indexes comprising a satisfiable subset.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.set_phase_saving">
<code class="descname">set_phase_saving</code><span class="sig-paren">(</span><em>ps</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.set_phase_saving" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the level of phase saving (0=none, 1=limited, 2=full (default)).</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.set_rnd_pol">
<code class="descname">set_rnd_pol</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.set_rnd_pol" title="Permalink to this definition">¶</a></dt>
<dd><p>Set whether random polarities are used for decisions (overridden if vars are created with a user polarity other than None)</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.set_varcounts">
<code class="descname">set_varcounts</code><span class="sig-paren">(</span><em>vars</em>, <em>constraints</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.set_varcounts" title="Permalink to this definition">¶</a></dt>
<dd><p>Record how many of the solver&#8217;s variables and clauses are
&#8220;original,&#8221; as opposed to clause-selector variables, etc.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.simplify">
<code class="descname">simplify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Call Solver.simplify().</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the current set of clauses, optionally with a set of assumptions.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>assumptions:</dt>
<dd>An optional iterable returning literals as integers, specified as
in <code class="docutils literal"><span class="pre">add_clause()</span></code>.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>True if the clauses (and assumptions) are satisfiable, False otherwise.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.solve_subset">
<code class="descname">solve_subset</code><span class="sig-paren">(</span><em>subset</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.solve_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a subset of the constraints equal containing all &#8220;hard&#8221;
clauses (those added with the regular <code class="docutils literal"><span class="pre">add_clause()</span></code> method) and the
specified subset of soft clauses.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>subset:</dt>
<dd>An iterable containing the indexes of any soft clauses to be included.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>True if the given subset is satisfiable, False otherwise.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinisatSubsetSolver.unsat_core">
<code class="descname">unsat_core</code><span class="sig-paren">(</span><em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinisatSubsetSolver.unsat_core" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an UNSAT core from the last check performed by
<code class="docutils literal"><span class="pre">solve_subset()</span></code>.  Assumes the last such check was UNSAT.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>offset (int):</dt>
<dd>Optional offset to be added to the zero-based indexes from
MiniSat.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of constraint indexes comprising an UNSAT core.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="minisolvers.MinicardSubsetSolver">
<em class="property">class </em><code class="descclassname">minisolvers.</code><code class="descname">MinicardSubsetSolver</code><a class="headerlink" href="#minisolvers.MinicardSubsetSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">minisolvers.SubsetMixin</span></code>, <a class="reference internal" href="#minisolvers.MinicardSolver" title="minisolvers.MinicardSolver"><code class="xref py py-class docutils literal"><span class="pre">minisolvers.MinicardSolver</span></code></a></p>
<p>A class for reasoning about subsets of constraints within MiniCard.</p>
<p>This has the same interface as <a class="reference internal" href="#minisolvers.MinisatSubsetSolver" title="minisolvers.MinisatSubsetSolver"><code class="xref py py-class docutils literal"><span class="pre">MinisatSubsetSolver</span></code></a>, with the
addition of the <code class="docutils literal"><span class="pre">add_atmost()</span></code> method.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">MinicardSubsetSolver</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">set_varcounts</span><span class="p">(</span><span class="nb">vars</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">constraints</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="o">+</span><span class="mi">4</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_</span>  <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">new_var</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">clause</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]]):</span>
<span class="gp">... </span>    <span class="n">S</span><span class="o">.</span><span class="n">add_clause_instrumented</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>AtMost constraints cannot be instrumented &#8211; they must be hard constraints.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">add_atmost</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">solve_subset</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">solve_subset</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">core</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">unsat_core</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">core</span><span class="p">)</span>
<span class="go">[0, 1, 2]</span>
</pre></div>
</div>
<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.add_atmost">
<code class="descname">add_atmost</code><span class="sig-paren">(</span><em>lits</em>, <em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.add_atmost" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an AtMost constraint to the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>lits:</dt>
<dd>A list of literals as integers.  Each integer specifies a
variable with <strong>1</strong>-based counting and a sign via the sign of
the integer.  Ex.: [-1, 2, -3] is {!x0, x1, !x2}</dd>
<dt>k (int):</dt>
<dd>The [upper] bound to place on these literals.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A boolean value returned from MiniCard&#8217;s <code class="docutils literal"><span class="pre">addAtMost()</span></code>
function, indicating success (True) or conflict (False).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.add_clause">
<code class="descname">add_clause</code><span class="sig-paren">(</span><em>lits</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.add_clause" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a clause to the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>lits:</dt>
<dd>A list of literals as integers.  Each integer specifies a
variable with <em>1</em>-based counting and a sign via the sign of the
integer.  Ex.: [-1, 2, -3] is (!x0 + x1 + !x2)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A boolean value returned from MiniSat&#8217;s <code class="docutils literal"><span class="pre">addClause()</span></code> function,
indicating success (True) or conflict (False).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.add_clause_instrumented">
<code class="descname">add_clause_instrumented</code><span class="sig-paren">(</span><em>lits</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.add_clause_instrumented" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a &#8220;soft&#8221; clause with a relaxation variable (the relaxation var.
is based on the index, which is assumed to be 0-based).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>lits:</dt>
<dd>A list of literals specified as in <code class="docutils literal"><span class="pre">add_clause()</span></code>.</dd>
<dt>index (int):</dt>
<dd>A 0-based index into the set of soft clauses.  The clause will
be given a relaxation variable based on this index, and it will
be used to specify the clause in subsets for
<code class="docutils literal"><span class="pre">solve_subset()</span></code>, etc.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.get_model">
<code class="descname">get_model</code><span class="sig-paren">(</span><em>start=0</em>, <em>end=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.get_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current model from the solver, optionally retrieving only a slice.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>start, end (int):</dt>
<dd>Optional start and end indices, interpreted as in <code class="docutils literal"><span class="pre">range()</span></code>.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of booleans indexed to each variable (from 0).  If a start
index was given, the returned list starts at that index (i.e.,
<code class="docutils literal"><span class="pre">get_model(10)[0]</span></code> is index 10 from the solver&#8217;s model.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.get_model_trues">
<code class="descname">get_model_trues</code><span class="sig-paren">(</span><em>start=0</em>, <em>end=-1</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.get_model_trues" title="Permalink to this definition">¶</a></dt>
<dd><p>Get variables assigned true in the current model from the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>start, end (int):</dt>
<dd>Optional start and end indices, interpreted as in <code class="docutils literal"><span class="pre">range()</span></code>.</dd>
<dt>offset (int):</dt>
<dd>Optional offset to be added to the zero-based variable numbers
from MiniSat.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of true variables in the solver&#8217;s current model.  If a
start index was given, the variables are indexed from that value.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.implies">
<code class="descname">implies</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.implies" title="Permalink to this definition">¶</a></dt>
<dd><p>Get literals known to be implied by the current formula.  (I.e., all
assignments made at level 0.)</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>An array of literals.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.model_value">
<code class="descname">model_value</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.model_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of a given variable in the current model.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.nclauses">
<code class="descname">nclauses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.nclauses" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of clauses or constraints added to the solver.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.new_var">
<code class="descname">new_var</code><span class="sig-paren">(</span><em>polarity=None</em>, <em>dvar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.new_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new variable in the solver.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>polarity (bool):</dt>
<dd>The default polarity for this variable.  True = variable&#8217;s
default is True, etc.  Note that this is the reverse of the &#8216;user
polarity&#8217; in MiniSat, where True indicates the <em>sign</em> is True,
hence the default value is False.</dd>
<dt>dvar (bool):</dt>
<dd>Whether this variable will be used as a decision variable.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>The new variable&#8217;s index (0-based counting).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.nvars">
<code class="descname">nvars</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.nvars" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of variables created in the solver.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.sat_subset">
<code class="descname">sat_subset</code><span class="sig-paren">(</span><em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.sat_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the set of clauses satisfied in the last check performed by
<code class="docutils literal"><span class="pre">solve_subset()</span></code>.  Assumes the last such check was SAT.  This may
contain additional soft clauses not in the subset that was given to
<code class="docutils literal"><span class="pre">solve_subset()</span></code>, if they were also satisfied by the model found.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>offset (int):</dt>
<dd>Optional offset to be added to the zero-based indexes from
MiniSat.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of constraint indexes comprising a satisfiable subset.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.set_phase_saving">
<code class="descname">set_phase_saving</code><span class="sig-paren">(</span><em>ps</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.set_phase_saving" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the level of phase saving (0=none, 1=limited, 2=full (default)).</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.set_rnd_pol">
<code class="descname">set_rnd_pol</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.set_rnd_pol" title="Permalink to this definition">¶</a></dt>
<dd><p>Set whether random polarities are used for decisions (overridden if vars are created with a user polarity other than None)</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.set_varcounts">
<code class="descname">set_varcounts</code><span class="sig-paren">(</span><em>vars</em>, <em>constraints</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.set_varcounts" title="Permalink to this definition">¶</a></dt>
<dd><p>Record how many of the solver&#8217;s variables and clauses are
&#8220;original,&#8221; as opposed to clause-selector variables, etc.</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.simplify">
<code class="descname">simplify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Call Solver.simplify().</p>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>assumptions=None</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the current set of clauses, optionally with a set of assumptions.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>assumptions:</dt>
<dd>An optional iterable returning literals as integers, specified as
in <code class="docutils literal"><span class="pre">add_clause()</span></code>.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>True if the clauses (and assumptions) are satisfiable, False otherwise.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.solve_subset">
<code class="descname">solve_subset</code><span class="sig-paren">(</span><em>subset</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.solve_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a subset of the constraints equal containing all &#8220;hard&#8221;
clauses (those added with the regular <code class="docutils literal"><span class="pre">add_clause()</span></code> method) and the
specified subset of soft clauses.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>subset:</dt>
<dd>An iterable containing the indexes of any soft clauses to be included.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>True if the given subset is satisfiable, False otherwise.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="minisolvers.MinicardSubsetSolver.unsat_core">
<code class="descname">unsat_core</code><span class="sig-paren">(</span><em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#minisolvers.MinicardSubsetSolver.unsat_core" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an UNSAT core from the last check performed by
<code class="docutils literal"><span class="pre">solve_subset()</span></code>.  Assumes the last such check was UNSAT.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>offset (int):</dt>
<dd>Optional offset to be added to the zero-based indexes from
MiniSat.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>An array of constraint indexes comprising an UNSAT core.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">PyMiniSolvers 0.9 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Mark Liffiton.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>